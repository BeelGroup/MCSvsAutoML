"""
Module to specify the different types of TPOT jobs
"""
import os
import json
from shutil import rmtree
from abc import abstractmethod
from typing import Iterable, Tuple, Dict, List, Union, Any, Mapping, Literal

from tpot.config import classifier_config_dict
from slurmjobmanager import SlurmJob, SlurmEnvironment

from .custom_json_encoder import CustomEncoder

#pylint: disable=too-many-instance-attributes
class TPOTJob(SlurmJob):
    """ Base class for tpot based algorithm jobs """

    #pylint: disable=too-many-arguments
    @abstractmethod
    def __init__(
            self,
            env: SlurmEnvironment,
            seed: int,
            openml_task_id: int,
            times: Iterable[int],
            benchdir: str,
            splits: Tuple[float, float, float],
            runner_path: str,
            *args,
            **kwargs
    ) -> None:
        super().__init__(env)
        self.seed = seed
        self.openml_task_id = openml_task_id
        self.splits = splits
        self.times = sorted(times)
        self.benchdir = benchdir
        self.runner_path = runner_path

        # Temporary name reduction for clarity
        join = os.path.join

        root = join(self.benchdir, self.name())
        self.folders : Dict[str, str] = {
            'root': root,
            'tmp': join(root, 'tmp'),
            'logs': join(root, 'logs'),
            'slurm': join(root, 'slurm'),
            'exports': join(root, 'exports'),
            'predictions': join(root, 'predictions'),
            'checkpoints': join(root, 'checkpoints'),
            'classifications': join(root, 'classifications'),
        }

        # Nameable files
        self.files : Dict[str,str] = {
            'slurm_out': join(self.folders['slurm'], 'out'),
            'slurm_err': join(self.folders['slurm'], 'err'),
            'slurm_script': join(self.folders['slurm'], 'script'),
            'tpot_log': join(self.folders['logs'], 'tpot_log'),
            'config': join(self.folders['root'], 'config.json')
        }

    @abstractmethod
    def create_config(self) -> Mapping[str, Any]:
        """ Create the config for the job to run on """
        raise NotImplementedError

    def classification_filename(self, time: int) -> str:
        """
        Params
        ======
        time: int
            The time in minutes after which the classifications were generated

        Returns
        =======
        str
            Path to the classifications
        """
        return f'classifications_{time}.npy'

    def classification_path(self, time: int) -> str:
        """
        Returns
        =======
        str:
            Path to the classifications for at a certain time
        """
        return os.path.join(self.folders['classifications'],
                            self.classification_filename(time))

    def classification_paths(self) -> List[str]:
        """
        Returns
        =======
        List[str]
            Paths to all the classifications that should be generated by this
            job.
        """
        return [self.classification_path(time) for time in self.times]

    def prediction_filename(self, time: int) -> str:
        """
        Params
        ======
        time: int
            The time in minutes after which the predictions were generated

        Returns
        =======
        str
            Path to the predictions
        """
        return f'predictions_{time}.npy'

    def prediction_path(self, time: int) -> str:
        """
        Returns
        =======
        str
            Path to predictions generated at a certain time
        """
        return os.path.join(self.folders['predictions'],
                            self.prediction_filename(time))

    def prediction_paths(self) -> List[str]:
        """
        Returns
        =======
        List[str]
            Paths to all the predictions that should be generated by this job.
        """
        return [ self.prediction_path(time) for time in self.times ]

    def export_filename(self, time: int) -> str:
        """
        Params
        ======
        time: int
            The time in minutes after which the export was generated

        Returns
        =======
        str
            Path to the export
        """
        return f'export_{time}.py'

    def export_path(self, time: int) -> str:
        """
        Returns
        =======
        str
            Path to the export at a given time
        """
        return os.path.join(self.folders['exports'],
                            self.export_filename(time))

    def export_paths(self) -> List[str]:
        """
        Returns
        =======
        List[str]
            Paths to all the exports that should be generated by this job.
        """
        return [ self.export_path(time) for time in self.times ]

    def checkpoint_paths(self) -> List[str]:
        """
        Returns
        =======
        List[str]
            Path to all the checkpoints currently generated by this job.
        """
        return os.listdir(self.folders['checkpoints'])

    def complete(self) -> bool:
        # Originally also checked for probability prediction files
        # but not all models supported a probability score
        files = self.classification_paths()
        return all(os.path.exists(file) for file in files)

    def failed(self) -> bool:
        return (
            not self.complete()
            and os.path.exists(self.files['slurm_out'])
            and not self.in_progress()
        )

    def ready(self) -> bool:
        return not self.blocked()

    def setup(self) -> None:
        if not os.path.exists(self.folders['root']):
            os.mkdir(self.folders['root'])

        for path in self.folders.values():
            if not os.path.exists(path):
                os.mkdir(path)

        config = self.create_config()
        with open(self.files['config'], 'w') as config_file:
            json.dump(config, config_file, indent=4, cls=CustomEncoder)

    def reset(self) -> None:
        rmtree(self.folders['root'])

    # TODO improve Typing
    def slurm_args(self) -> Dict[str, Union[int, str]]:
        total_time = max(self.times)
        return {
            'job-name': self.name(),
            'nodes': 1,
            'ntasks': 1,
            'cpus-per-task': 4,
            'output': self.files['slurm_out'],
            'error': self.files['slurm_err'],
            'export': 'ALL',
            'mem': 16000,
            **self.env.slurm_time_and_partition(total_time, buffer=0.4)
        }

    def slurm_opts(self) -> List[str]:
        return []

    def slurm_command(self) -> str:
        command = [
            f'TMPDIR={self.folders["tmp"]}',
            'python',
            f'{self.runner_path}',
            f'{self.files["config"]}'
        ]
        return ' '.join(command)

    def slurm_script_path(self) -> str:
        return self.files['slurm_script']

    # TODO improve Typing
    def default_tpot_params(self) -> Dict[str, Any]:
        """
        Returns
        =======
        Dict[str, Any]
            A dict ofdefault params to be used by tpot
        """
        return {
            'generations': None,
            'population_size': 100,
            'offspring_size': None,
            'mutation_rate': 0.9,
            'crossover_rate': 0.1,
            'scoring': 'accuracy',
            'cv': 5,
            'subsample': 1.0,
            'n_jobs': 4,
            'max_time_mins': self.times[0],
            'max_eval_time_mins': 8,
            'random_state': self.seed,
            'config_dict': None,
            'template': None,
            'warm_start': True,
            'memory': 'auto',
            'use_dask': False,
            'periodic_checkpoint_folder': self.folders['checkpoints'],
            'early_stop': None,
            'verbosity': 3,
            'disable_update_check': False,
            'log_file': self.files['tpot_log']
        }


class SingleAlgorithmJob(TPOTJob):
    """
    A job class for training a single family of algorithms on an openml task
    """

    category_keys : Dict[str, List[str]] = {
        'KNN': ['sklearn.neighbors.KNeighborsClassifier'],
        'LR': ['sklearn.linear_model.LogisticRegression'],
        'MLP': ['sklearn.neural_network.MLPClassifier'],
        'SGD': ['sklearn.linear_model.SGDClassifier'],
        'XGB': ['xgboost.XGBClassifier'],
        'SVM': ['sklearn.svm.LinearSVC'],
        'NB': ['sklearn.naive_bayes.GaussianNB',
               'sklearn.naive_bayes.BernoulliNB',
               'sklearn.naive_bayes.MultinomialNB'],
        'TR': ['sklearn.tree.DecisionTreeClassifier',
               'sklearn.ensemble.ExtraTreesClassifier',
               'sklearn.ensemble.RandomForestClassifier',
               'sklearn.ensemble.GradientBoostingClassifier'],
    }

    #pylint: disable=too-many-arguments
    def __init__(
        self,
        env: SlurmEnvironment,
        seed: int,
        times: Iterable[int],
        openml_task_id: int,
        benchdir: str,
        splits: Tuple[float, float, float],
        algorithm_family: str,
        runner_path: str
    ) -> None:
        self.algorithm_family = algorithm_family
        super().__init__(env, seed, openml_task_id, times, benchdir, splits,
                         runner_path)
        self.folders['selector_training_classifications'] = os.path.join(
            self.folders['root'], 'selector_training_classifications'
        )
        self.folders['selector_training_predictions'] = os.path.join(
            self.folders['root'], 'selector_training_predictions'
        )

    def selector_training_classification_path(self, time: int) -> str:
        folder = self.folders['selector_training_classifications']
        return os.path.join(folder,
                            f'selector_training_classifications_{time}.npy')

    def selector_training_classifications_paths(self) -> List[str]:
        return [
            self.selector_training_classification_path(time)
            for time in self.times
        ]

    def selector_training_predictions_path(self, time: int) -> str:
        folder = self.folders['selector_training_predictions']
        return os.path.join(folder, f'selector_training_predictions_{time}.npy')

    def selector_training_predictions_paths(self) -> List[str]:
        return [
            self.selector_training_predictions_path(time)
            for time in self.times
        ]

    #overwrite
    def complete(self) -> bool:
        files = self.classification_paths() \
            + self.selector_training_classifications_paths()
        return all(os.path.exists(file) for file in files)

    def name(self) -> str:
        return f'a{self.algorithm_family}_s{self.seed}_t{self.openml_task_id}'

    def blocked(self) -> bool:
        return False

    def create_config(self) -> Dict[str, Any]:
        keys = SingleAlgorithmJob.category_keys[self.algorithm_family]

        params = self.default_tpot_params()
        params['config_dict'] = { k: classifier_config_dict[k] for k in keys }

        return {
            'seed': self.seed,
            'openml_task_id': self.openml_task_id,
            'times': self.times,
            'splits': self.splits,
            'folders': self.folders,
            'files': self.files,
            'algorithm_family': self.algorithm_family,
            'tpot_params': params,
        }


class BaselineJob(TPOTJob):
    """
    A Job class for running a baseline TPOT that searches all possible
    algorithms.
    """

    #pylint: disable=too-many-arguments
    def __init__(
        self,
        env: SlurmEnvironment,
        seed: int,
        times: Iterable[int],
        openml_task_id: int,
        benchdir: str,
        splits: Tuple[float, float, float],
        runner_path: str
    ) -> None:
        super().__init__(env, seed, openml_task_id, times, benchdir, splits, runner_path)

    def name(self) -> str:
        return f'b_s{self.seed}_t{self.openml_task_id}'

    def blocked(self) -> bool:
        return False

    def create_config(self) -> Dict[str, Any]:
        return {
            'seed': self.seed,
            'openml_task_id': self.openml_task_id,
            'times': self.times,
            'splits': self.splits,
            'folders': self.folders,
            'files': self.files,
            'tpot_params': self.default_tpot_params(),
        }


class SelectorJob(TPOTJob):
    """
    A job class for a Selector job on a specific openml task
    """
    selection_methods = Literal['all', 'top_n', 'n_least_overlapping',
                                'n_most_coverage', 'n_random_selection']

    # pylint: disable=too-many-arguments
    def __init__(
        self,
        env: SlurmEnvironment,
        seed: int,
        times: Iterable[int],
        openml_task_id: int,
        benchdir: str,
        splits: Tuple[float, float, float],
        runner_path: str,
        selector_name: str,
        single_algorithms: Iterable[SingleAlgorithmJob]
    ) -> None:
        self.selector_name = selector_name
        self.single_algorithms = single_algorithms
        super().__init__(env, seed, openml_task_id, times, benchdir, splits,
                         runner_path)
        self.folders['autosklearn_tmp'] = os.path.join(
            self.folders['root'], 'autosklearn_tmp'
        )
        self.folders['autosklearn_output'] = os.path.join(
            self.folders['root'], 'autosklearn_output'
        )

    def name(self) -> str:
        return f's{self.selector_name}_s{self.seed}_t{self.openml_task_id}'

    def blocked(self) -> bool:
        return not all(algo.complete() for algo in self.single_algorithms)

    def create_config(self) -> Dict[str, Any]:
        return {
            'seed': self.seed,
            'openml_task_id': self.openml_task_id,
            'times': self.times,
            'splits': self.splits,
            'folders': self.folders,
            'files': self.files,
            'autosklearn_params': {
                'time_left_for_this_task': 2*60*60,
                'seed': self.seed,
                'tmp_folder': self.folders['autosklearn_tmp'],
                'output_folder': self.folders['autosklearn_output'],
                'n_jobs': 4,
            },
            'algorithms': {
                'selector_training_classifications' : {
                    time : {
                        algo.name() : algo.selector_training_classification_path(time)
                        for algo in self.single_algorithms
                    }
                    for time in self.times
                },
                'test_classifications' : {
                    time : {
                        algo.name() : algo.classification_path(time)
                        for algo in self.single_algorithms
                    }
                    for time in self.times
                }
            }
        }
